package pl.marwin1991.bbdivr.chaincode.vulnerability;

import com.google.gson.Gson;
import org.hyperledger.fabric.contract.Context;
import org.hyperledger.fabric.contract.ContractInterface;
import org.hyperledger.fabric.contract.annotation.*;
import org.hyperledger.fabric.shim.ChaincodeException;
import org.hyperledger.fabric.shim.ChaincodeStub;
import org.hyperledger.fabric.shim.ledger.KeyValue;
import org.hyperledger.fabric.shim.ledger.QueryResultsIteratorWithMetadata;
import pl.marwin1991.bbdivr.chaincode.common.BbdivrChainCodeErrors;
import pl.marwin1991.bbdivr.chaincode.layer.ChainCodeLayer;

import java.util.LinkedList;
import java.util.List;

@Contract(
        name = "bbdivr-vulnerability",
        info = @Info(
                title = "bbdivr vulnerability contract",
                description = "bbdivr vulnerability contract to store and manage data about vulnerabilities",
                version = "1.0.0-SNAPSHOT",
                license = @License(
                        name = "Apache 2.0 License",
                        url = "http://www.apache.org/licenses/LICENSE-2.0.html"),
                contact = @Contact(
                        email = "peter.zmilczak@gmail.com",
                        name = "Peter Zmilczak",
                        url = "https://github.com/marwin1991")))
@Default
public final class BbdivrVulnerabilityContract implements ContractInterface {

    private final Gson jsonConverter = new Gson();

    /**
     * Retrieves a vulnerability description.
     *
     * @param ctx             the transaction context
     * @param vulnerabilityId the vulnerabilityId
     * @return the Car found on the ledger if there was one
     */
    @Transaction()
    public ChainCodeVulnerability queryVulnerability(final Context ctx, final String vulnerabilityId) {
        return getExistingVulnerability(ctx, vulnerabilityId);
    }


    /**
     * Adds a new vulnerability to the ledger.
     *
     * @param ctx                 the transaction context
     * @param vulnerabilityId     the vulnerability id of the new vulnerability
     * @param vulnerabilityAsJson the string representation of vulnerability
     * @return the created vulnerability
     */

    @Transaction()
    public ChainCodeLayer addVulnerability(final Context ctx, final String vulnerabilityId, final String vulnerabilityAsJson) {
        ChaincodeStub stub = ctx.getStub();

        //check if vulnerability already exists
        getVulnerability(ctx, vulnerabilityId, false);

        stub.putStringState(vulnerabilityId, vulnerabilityAsJson);

        return jsonConverter.fromJson(vulnerabilityAsJson, ChainCodeLayer.class);
    }

    /**
     * Retrieves page of Vulnerabilities.
     * To get first page pageId should be empty string
     *
     * @param ctx the transaction context
     * @return page containing vulnerabilities found on the ledger
     */
    @Transaction()
    public ChainCodePageVulnerabilities queryPagedVulnerabilities(final Context ctx, final String pageId, final String pageSize) {
        ChaincodeStub stub = ctx.getStub();

        final String startKey = "";
        final String endKey = "";
        final int pageSizeInt = Integer.parseInt(pageSize) + 1; //increase to get next bookmark

        List<ChainCodeVulnerability> vulnerabilities = new LinkedList<>();
        QueryResultsIteratorWithMetadata<KeyValue> results = stub.getStateByRangeWithPagination(startKey, endKey, pageSizeInt, pageId);

        results.forEach(r -> vulnerabilities.add(jsonConverter.fromJson(r.getStringValue(), ChainCodeVulnerability.class)));


        ChainCodePageVulnerabilities pageVulnerabilities = new ChainCodePageVulnerabilities();
        pageVulnerabilities.setPageId(results.getMetadata().getBookmark());

        if (pageSizeInt == vulnerabilities.size())
            pageVulnerabilities.setNextPageId(vulnerabilities.get(vulnerabilities.size() - 1).getId());

        pageVulnerabilities.setPageSize(pageSizeInt - 1);

        //removes last element if exist, as it is returned only to get bookmark
        if (vulnerabilities.size() > 0)
            vulnerabilities.remove(vulnerabilities.size() - 1);

        pageVulnerabilities.setVulnerabilities(vulnerabilities);

        return pageVulnerabilities;
    }

    private ChainCodeVulnerability getExistingVulnerability(final Context ctx, final String vulnerabilityId) {
        ChaincodeStub stub = ctx.getStub();
        String vulnerabilityState = stub.getStringState(vulnerabilityId);

        if (vulnerabilityState.isEmpty()) {
            String errorMessage = String.format("Vulnerability with id: %s does not exist", vulnerabilityId);
            System.out.println(errorMessage);
            throw new ChaincodeException(errorMessage, BbdivrChainCodeErrors.VULNERABILITY_NOT_FOUND.toString());
        }

        return jsonConverter.fromJson(vulnerabilityState, ChainCodeVulnerability.class);
    }


    private ChainCodeVulnerability getVulnerability(final Context ctx, final String vulnerabilityId, boolean shouldExists) {
        ChaincodeStub stub = ctx.getStub();
        String layerState = stub.getStringState(vulnerabilityId);

        if (layerState.isEmpty()) {
            if (shouldExists) {
                String errorMessage = String.format("Vulnerability with id: %s does not exist", vulnerabilityId);
                System.out.println(errorMessage);
                throw new ChaincodeException(errorMessage, BbdivrChainCodeErrors.VULNERABILITY_NOT_FOUND.toString());
            } else {
                return ChainCodeVulnerability.builder().build();
            }
        } else {
            if (shouldExists) {
                return jsonConverter.fromJson(layerState, ChainCodeVulnerability.class);
            } else {
                String errorMessage = String.format("Vulnerability with id: %s already exists", vulnerabilityId);
                System.out.println(errorMessage);
                throw new ChaincodeException(errorMessage, BbdivrChainCodeErrors.VULNERABILITY_ALREADY_EXIST.toString());
            }
        }
    }
}